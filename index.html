<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ü§ñ AI Trading Bot - JERCAT FIXED</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        body {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            min-height: 100vh;
            color: white;
        }
        .ai-card {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s;
        }
        .ai-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }
        .ai-card.active {
            border: 3px solid #10b981;
            box-shadow: 0 0 25px rgba(16, 185, 129, 0.5);
        }
        .trade-log {
            max-height: 400px;
            overflow-y: auto;
        }
        .card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .pulse {
            animation: pulse 2s ease-in-out infinite;
        }
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        .status-online { background: #10b981; box-shadow: 0 0 10px #10b981; }
        .status-trading { background: #f59e0b; animation: pulse 1s infinite; }
    </style>
</head>
<body class="p-4 md:p-6">
    <div class="max-w-7xl mx-auto">
        
        <!-- AVERTISSEMENT CRITIQUE -->
        <div class="bg-red-900 border-4 border-red-500 rounded-xl p-6 mb-6">
            <h2 class="text-3xl font-bold text-red-200 mb-4">‚ö†Ô∏è MODE TRADING R√âEL ACTIV√â</h2>
            <div class="text-red-200 space-y-2">
                <p class="font-bold text-lg">üî¥ AVERTISSEMENT CRITIQUE - LISEZ ATTENTIVEMENT :</p>
                <ul class="list-disc ml-6 space-y-1">
                    <li><strong>VRAI ARGENT</strong> - Toutes les transactions sont r√©elles sur BSC Mainnet</li>
                    <li><strong>IRR√âVERSIBLE</strong> - Les transactions blockchain ne peuvent pas √™tre annul√©es</li>
                    <li><strong>RISQUE √âLEV√â</strong> - Trading automatique = d√©cisions sans votre validation</li>
                </ul>
            </div>
        </div>

        <!-- Header -->
        <div class="text-center mb-8">
            <div class="flex items-center justify-center gap-3 mb-3">
                <span class="status-dot status-trading"></span>
                <h1 class="text-4xl md:text-5xl font-bold bg-gradient-to-r from-green-400 to-blue-500 bg-clip-text text-transparent">
                    ü§ñ AI Trading Bot - LIVE
                </h1>
            </div>
            <p class="text-gray-300 text-lg">Claude vs Gemini vs ChatGPT vs Grok ‚Ä¢ Trading R√©el 24/7 via PancakeSwap</p>
            <div class="mt-3 flex justify-center gap-4 items-center flex-wrap">
                <span class="px-4 py-2 bg-green-900 bg-opacity-50 text-green-300 rounded-full font-semibold text-sm border border-green-500">ü•û PancakeSwap V2</span>
                <span class="px-4 py-2 bg-blue-900 bg-opacity-50 text-blue-300 rounded-full font-semibold text-sm border border-blue-500">üîó BSC Mainnet</span>
                <span class="px-4 py-2 bg-yellow-900 bg-opacity-50 text-yellow-300 rounded-full font-semibold text-sm border border-yellow-500">üíé Taxe JERCAT: 0.001 BNB/trade</span>
                <span class="px-4 py-2 bg-red-900 bg-opacity-50 text-red-300 rounded-full font-semibold text-sm border border-red-500 pulse">üî¥ LIVE TRADING</span>
            </div>
        </div>

        <!-- Configuration -->
        <div class="card p-6 mb-6">
            <h2 class="text-2xl font-bold mb-4">üîê Configuration & Connexion</h2>

            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label class="block text-sm text-gray-300 mb-2 font-semibold">Mode de connexion</label>
                    <select id="connectionMode" onchange="switchConnectionMode()" class="w-full bg-gray-800 border-2 border-gray-600 rounded-lg px-4 py-3 text-white">
                        <option value="jercat">üíé JERCAT Wallet (Recommand√©)</option>
                        <option value="metamask">ü¶ä MetaMask</option>
                        <option value="privatekey">‚ö° Cl√© Priv√©e (Auto 24/7 - Dangereux)</option>
                    </select>
                </div>
                
                <div>
                    <label class="block text-sm text-gray-300 mb-2 font-semibold">Statut</label>
                    <div class="bg-gray-800 border-2 border-gray-600 rounded-lg px-4 py-3">
                        <span id="connectionStatus" class="flex items-center text-gray-400">
                            <span class="status-dot bg-gray-500"></span>
                            Non connect√©
                        </span>
                    </div>
                </div>
            </div>

            <!-- JERCAT Wallet Section -->
            <div id="jercatSection" class="mb-4">
                <div class="bg-gradient-to-r from-purple-900 to-pink-900 border-2 border-purple-500 rounded-lg p-4 mb-4">
                    <p class="text-purple-200 font-bold mb-2">üíé JERCAT WALLET - M√âTHODE RECOMMAND√âE</p>
                    <ul class="text-sm text-purple-200 space-y-1">
                        <li>‚Ä¢ Wallet d√©di√© au trading JERCAT</li>
                        <li>‚Ä¢ Interface simplifi√©e et s√©curis√©e</li>
                        <li>‚Ä¢ Gestion automatique des approvals</li>
                        <li>‚Ä¢ Compatible BSC uniquement</li>
                    </ul>
                </div>
                <button onclick="connectJERCAT()" id="connectJercatBtn" class="w-full px-6 py-3 bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white rounded-lg font-bold">
                    üíé Connecter JERCAT Wallet
                </button>
            </div>

            <!-- MetaMask Section -->
            <div id="metamaskSection" style="display: none;">
                <button onclick="connectMetaMask()" id="connectBtn" class="w-full px-6 py-3 bg-gradient-to-r from-orange-500 to-yellow-500 hover:from-orange-600 hover:to-yellow-600 text-white rounded-lg font-bold">
                    Connecter MetaMask
                </button>
            </div>

            <!-- Private Key Section -->
            <div id="privatekeySection" style="display: none;">
                <div class="bg-red-900 border-2 border-red-500 rounded-lg p-4 mb-4">
                    <p class="text-red-200 font-bold mb-2">‚ö†Ô∏è MODE TR√àS DANGEREUX</p>
                    <ul class="text-sm text-red-200 space-y-1">
                        <li>‚Ä¢ La cl√© priv√©e donne acc√®s TOTAL √† votre wallet</li>
                        <li>‚Ä¢ Si ce site est compromis, vos fonds sont vol√©s</li>
                        <li>‚Ä¢ Utilisez UNIQUEMENT un wallet test avec peu de fonds</li>
                    </ul>
                </div>
                
                <input type="password" id="privateKeyInput" placeholder="0x..." class="w-full bg-gray-800 border-2 border-red-500 rounded-lg px-4 py-3 mb-3 text-white font-mono">
                <button onclick="connectWithPrivateKey()" class="w-full px-6 py-3 bg-gradient-to-r from-red-600 to-orange-600 hover:from-red-700 hover:to-orange-700 text-white rounded-lg font-bold">
                    ‚ö° Activer Mode Auto (Risqu√©)
                </button>
            </div>

            <div id="walletInfo" class="grid grid-cols-2 md:grid-cols-4 gap-3 mt-4" style="display: none;">
                <div class="bg-gray-800 border border-gray-600 rounded-lg p-3">
                    <p class="text-xs text-gray-400">Adresse</p>
                    <p class="font-mono text-sm text-white" id="walletAddress">-</p>
                </div>
                <div class="bg-yellow-900 bg-opacity-30 border border-yellow-600 rounded-lg p-3">
                    <p class="text-xs text-gray-400">BNB</p>
                    <p class="font-bold text-yellow-400" id="bnbBalance">0</p>
                </div>
                <div class="bg-green-900 bg-opacity-30 border border-green-600 rounded-lg p-3">
                    <p class="text-xs text-gray-400">USDT</p>
                    <p class="font-bold text-green-400" id="usdtBalance">0</p>
                </div>
                <div class="bg-blue-900 bg-opacity-30 border border-blue-600 rounded-lg p-3">
                    <p class="text-xs text-gray-400">R√©seau</p>
                    <p class="font-bold text-blue-400">BSC</p>
                </div>
            </div>

            <div class="mt-4 grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label class="block text-sm text-gray-300 mb-2 font-semibold">Capital de trading (USDT)</label>
                    <div class="flex gap-3">
                        <input type="number" id="tradingCapital" placeholder="50" value="50" class="flex-1 bg-gray-800 border-2 border-gray-600 rounded-lg px-4 py-3 text-white">
                        <button onclick="setCapital()" class="px-6 py-3 bg-gradient-to-r from-green-500 to-teal-500 hover:from-green-600 hover:to-teal-600 text-white rounded-lg font-bold">
                            Valider
                        </button>
                    </div>
                </div>

                <div>
                    <label class="block text-sm text-gray-300 mb-2 font-semibold">Slippage (%)</label>
                    <div class="flex gap-3">
                        <input type="number" id="slippageInput" value="3" min="0.5" max="10" step="0.5" class="flex-1 bg-gray-800 border-2 border-gray-600 rounded-lg px-4 py-3 text-white">
                        <button onclick="updateSlippage()" class="px-6 py-3 bg-gradient-to-r from-yellow-500 to-orange-500 hover:from-yellow-600 hover:to-orange-600 text-white rounded-lg font-bold">
                            OK
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- IA Selection -->
        <div class="card p-6 mb-6">
            <h2 class="text-2xl font-bold mb-4">ü§ñ S√©lection des IA</h2>
            
            <div class="bg-blue-900 bg-opacity-50 border-2 border-blue-500 rounded-lg p-4 mb-4">
                <p class="text-blue-200 font-bold mb-2">‚ÑπÔ∏è STRAT√âGIES DES IA (D√©terministes)</p>
                <ul class="text-sm text-blue-200 space-y-1">
                    <li>‚Ä¢ <strong>üß† Claude:</strong> Conservateur - RSI < 30, take profit +2%</li>
                    <li>‚Ä¢ <strong>üíé Gemini:</strong> √âquilibr√© - RSI < 35, take profit +3%</li>
                    <li>‚Ä¢ <strong>üöÄ ChatGPT:</strong> Momentum - EMA cross, take profit +4%</li>
                    <li>‚Ä¢ <strong>‚ö° Grok:</strong> Agressif - Momentum > 2%, take profit +5%</li>
                </ul>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-4" id="aiCards"></div>

            <div class="flex flex-wrap gap-4">
                <button onclick="startCompetition()" id="startBtn" class="flex-1 min-w-[200px] px-6 py-4 bg-gradient-to-r from-green-500 to-teal-500 hover:from-green-600 hover:to-teal-600 text-white rounded-lg font-bold text-lg" disabled>
                    üöÄ D√©marrer Trading LIVE
                </button>
                <button onclick="stopCompetition()" id="stopBtn" class="flex-1 min-w-[200px] px-6 py-4 bg-gradient-to-r from-red-500 to-orange-500 hover:from-red-600 hover:to-orange-600 text-white rounded-lg font-bold text-lg" style="display: none;">
                    ‚è∏Ô∏è STOP URGENCE
                </button>
            </div>
        </div>

        <!-- Prix & Classement -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
            <div class="lg:col-span-2 card p-6">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold">üìà Prix Temps R√©el</h2>
                    <div class="flex items-center gap-3">
                        <select id="cryptoSelect" onchange="changeCrypto()" class="bg-gray-800 border-2 border-gray-600 rounded-lg px-3 py-2 text-sm text-white">
                            <option value="BTCUSDT">BTC/USDT</option>
                            <option value="ETHUSDT">ETH/USDT</option>
                            <option value="BNBUSDT">BNB/USDT</option>
                        </select>
                        <div class="text-2xl font-bold text-green-400" id="currentPrice">$0</div>
                    </div>
                </div>
                <div class="h-80">
                    <canvas id="priceChart"></canvas>
                </div>
            </div>

            <div class="card p-6">
                <h2 class="text-2xl font-bold mb-4">üèÜ Classement</h2>
                <div id="leaderboard" class="space-y-3">
                    <div class="bg-gray-800 bg-opacity-50 rounded-lg p-4">
                        <p class="text-center text-gray-400">D√©marrez le trading</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Logs -->
        <div class="card p-6">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">üìä Journal des Transactions LIVE</h2>
                <button onclick="clearLogs()" class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-lg text-sm">
                    üóëÔ∏è Effacer
                </button>
            </div>
            <div id="tradeLogs" class="trade-log space-y-2">
                <div class="text-center text-gray-500 py-8">En attente de transactions...</div>
            </div>
        </div>
    </div>

    <script>
        // ============= CONFIG =============
        const CONFIG = {
            BSC_RPC: 'https://bsc-dataseed1.binance.org',
            CHAIN_ID: 56,
            USDT_ADDRESS: '0x55d398326f99059fF775485246999027B3197955',
            WBNB_ADDRESS: '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',
            PANCAKE_ROUTER: '0x10ED43C718714eb63d5aA57B78B54704E256024E',
            TOKEN_ADDRESSES: {
                'BTCUSDT': '0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c',
                'ETHUSDT': '0x2170Ed0880ac9A755fd29B2688956BD959F933F8',
                'BNBUSDT': '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c'
            },
            SLIPPAGE: 3.0,
            MIN_TRADE_AMOUNT: 10,
            TRADE_FEE_BNB: '0.001',
            FEE_WALLET: '0x7C08b7E9862bd3826c0de1741a2d26770C39903d',
            JERCAT_WALLET_URL: 'https://test-seven-mu-77.vercel.app/',
            
            ROUTER_ABI: [
                'function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] path, address to, uint deadline) returns (uint[] amounts)',
                'function getAmountsOut(uint amountIn, address[] path) view returns (uint[] amounts)'
            ],
            ERC20_ABI: [
                'function approve(address spender, uint256 amount) returns (bool)',
                'function allowance(address owner, address spender) view returns (uint256)',
                'function balanceOf(address account) view returns (uint256)',
                'function decimals() view returns (uint8)'
            ]
        };

        // ============= STATE =============
        let state = {
            connectionMode: 'jercat',
            account: null,
            provider: null,
            signer: null,
            privateKeyWallet: null,
            isConnected: false,
            balances: { bnb: 0, usdt: 0 },
            capital: 0,
            selectedCrypto: 'BTCUSDT',
            currentPrice: 0,
            priceHistory: [],
            activeAIs: { claude: false, gemini: false, chatgpt: false, grok: false },
            aiStats: {
                claude: { trades: 0, profit: 0, wins: 0, losses: 0 },
                gemini: { trades: 0, profit: 0, wins: 0, losses: 0 },
                chatgpt: { trades: 0, profit: 0, wins: 0, losses: 0 },
                grok: { trades: 0, profit: 0, wins: 0, losses: 0 }
            },
            positions: { claude: null, gemini: null, chatgpt: null, grok: null },
            competitionRunning: false,
            tradeLogs: []
        };

        let ws = null;
        let priceChart = null;
        let competitionInterval = null;

        // ============= INIT =============
        window.addEventListener('DOMContentLoaded', () => {
            console.log('üî¥ LIVE TRADING BOT - JERCAT FIXED VERSION');
            console.log('üí∞ Wallet JERCAT:', CONFIG.FEE_WALLET);
            initChart();
            renderAICards();
        });

        function renderAICards() {
            const ais = [
                { id: 'claude', icon: 'üß†', name: 'Claude', desc: 'Conservateur ‚Ä¢ RSI-based' },
                { id: 'gemini', icon: 'üíé', name: 'Gemini', desc: '√âquilibr√© ‚Ä¢ Multi-facteur' },
                { id: 'chatgpt', icon: 'üöÄ', name: 'ChatGPT', desc: 'Momentum ‚Ä¢ EMA cross' },
                { id: 'grok', icon: '‚ö°', name: 'Grok', desc: 'Agressif ‚Ä¢ High frequency' }
            ];

            const container = document.getElementById('aiCards');
            container.innerHTML = ais.map(ai => `
                <div class="ai-card rounded-xl p-5" id="card-${ai.id}">
                    <div class="flex items-center justify-between mb-3">
                        <div class="flex items-center gap-2">
                            <span class="text-3xl">${ai.icon}</span>
                            <h3 class="text-xl font-bold">${ai.name}</h3>
                        </div>
                        <input type="checkbox" id="ai-${ai.id}" onclick="toggleAI('${ai.id}')" class="w-5 h-5 cursor-pointer">
                    </div>
                    <p class="text-sm text-gray-400 mb-3">${ai.desc}</p>
                    <div class="space-y-2 text-xs">
                        <div class="flex justify-between">
                            <span class="text-gray-400">Trades:</span>
                            <span id="${ai.id}-trades" class="font-bold text-green-400">0</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-400">Profit:</span>
                            <span id="${ai.id}-profit" class="font-bold text-green-400">$0.00</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-400">Win Rate:</span>
                            <span id="${ai.id}-winrate" class="font-bold">0%</span>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function initChart() {
            const ctx = document.getElementById('priceChart').getContext('2d');
            priceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Prix',
                        data: [],
                        borderColor: '#10b981',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        borderWidth: 2,
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false, labels: { color: 'white' } } },
                    scales: {
                        x: { grid: { color: 'rgba(255, 255, 255, 0.1)' }, ticks: { color: 'white' } },
                        y: { grid: { color: 'rgba(255, 255, 255, 0.1)' }, ticks: { color: 'white' } }
                    }
                }
            });
        }

        // ============= TAXE PAYMENT =============
        async function payTradeFee(aiName) {
            const signer = state.signer;
            const feeAmount = ethers.utils.parseEther(CONFIG.TRADE_FEE_BNB);
            
            addLog(aiName, 'üí∞ TAXE', `Paiement ${CONFIG.TRADE_FEE_BNB} BNB...`);
            
            try {
                const tx = await signer.sendTransaction({
                    to: CONFIG.FEE_WALLET,
                    value: feeAmount,
                    gasLimit: 21000
                });
                
                addLog(aiName, '‚è≥ TAXE TX', `${tx.hash.slice(0, 10)}...`);
                
                const receipt = await tx.wait();
                addLog(aiName, '‚úÖ TAXE OK', `Block ${receipt.blockNumber}`);
                addLog(aiName, 'üîó BSCSCAN', `https://bscscan.com/tx/${tx.hash}`);
                
                return true;
            } catch (error) {
                console.error('‚ùå Taxe error:', error);
                addLog(aiName, '‚ùå TAXE FAILED', error.message);
                throw error;
            }
        }

        // ============= REAL TRADING FUNCTIONS =============
        
        async function executeBuyPancakeSwap(aiName, tradeAmount) {
            const signer = state.signer;
            const tokenAddress = CONFIG.TOKEN_ADDRESSES[state.selectedCrypto];
            
            addLog(aiName, 'ü•û PANCAKESWAP', 'Connexion router...');
            
            try {
                const routerContract = new ethers.Contract(CONFIG.PANCAKE_ROUTER, CONFIG.ROUTER_ABI, signer);
                const usdtContract = new ethers.Contract(CONFIG.USDT_ADDRESS, CONFIG.ERC20_ABI, signer);
                
                const amountIn = ethers.utils.parseUnits(tradeAmount.toString(), 18);
                
                const currentAllowance = await usdtContract.allowance(state.account, CONFIG.PANCAKE_ROUTER);
                
                if (currentAllowance.lt(amountIn)) {
                    addLog(aiName, 'üîì APPROVE', 'Approve USDT...');
                    const approveTx = await usdtContract.approve(CONFIG.PANCAKE_ROUTER, ethers.constants.MaxUint256, {
                        gasLimit: 100000
                    });
                    await approveTx.wait();
                    addLog(aiName, '‚úÖ APPROVED', 'USDT approved');
                }
                
                const path = [CONFIG.USDT_ADDRESS, tokenAddress];
                const amounts = await routerContract.getAmountsOut(amountIn, path);
                const amountOutMin = amounts[1].mul(100 - Math.floor(CONFIG.SLIPPAGE)).div(100);
                
                addLog(aiName, 'üìä ESTIMATION', `Expected: ${ethers.utils.formatUnits(amounts[1], 18)} tokens`);
                
                addLog(aiName, 'üí± SWAP', 'Executing swap...');
                const deadline = Math.floor(Date.now() / 1000) + 60 * 20;
                
                const swapTx = await routerContract.swapExactTokensForTokens(
                    amountIn,
                    amountOutMin,
                    path,
                    state.account,
                    deadline,
                    { gasLimit: 300000 }
                );
                
                addLog(aiName, '‚è≥ BLOCKCHAIN', `TX: ${swapTx.hash.slice(0, 10)}...`);
                
                const receipt = await swapTx.wait();
                
                const tokensReceived = parseFloat(ethers.utils.formatUnits(amounts[1], 18));
                
                addLog(aiName, '‚úÖ BUY SUCCESS', `${tokensReceived.toFixed(6)} tokens`);
                addLog(aiName, 'üîó BSCSCAN', `https://bscscan.com/tx/${swapTx.hash}`);
                addLog(aiName, 'üéâ CONFIRMED', `Block ${receipt.blockNumber} ‚Ä¢ Gas: ${receipt.gasUsed.toString()}`);
                
                return {
                    tokensAmount: tokensReceived,
                    txHash: swapTx.hash,
                    gasUsed: receipt.gasUsed
                };
                
            } catch (error) {
                console.error('‚ùå Buy error:', error);
                addLog(aiName, '‚ùå BUY FAILED', error.message);
                
                if (error.code === 'INSUFFICIENT_FUNDS') {
                    addLog(aiName, 'üí∏ ERROR', 'Pas assez de BNB pour le gas');
                } else if (error.message.includes('INSUFFICIENT_OUTPUT_AMOUNT')) {
                    addLog(aiName, 'üìâ ERROR', 'Slippage trop faible');
                }
                
                throw error;
            }
        }

        async function executeSellPancakeSwap(aiName, position) {
            const signer = state.signer;
            const tokenAddress = CONFIG.TOKEN_ADDRESSES[state.selectedCrypto];
            
            addLog(aiName, 'ü•û PANCAKESWAP', 'Preparing sell...');
            
            try {
                const routerContract = new ethers.Contract(CONFIG.PANCAKE_ROUTER, CONFIG.ROUTER_ABI, signer);
                const tokenContract = new ethers.Contract(tokenAddress, CONFIG.ERC20_ABI, signer);
                
                const balance = await tokenContract.balanceOf(state.account);
                const amountIn = ethers.utils.parseUnits(position.tokensAmount.toString(), 18);
                
                if (balance.lt(amountIn)) {
                    throw new Error('Insufficient token balance');
                }
                
                const currentAllowance = await tokenContract.allowance(state.account, CONFIG.PANCAKE_ROUTER);
                
                if (currentAllowance.lt(amountIn)) {
                    addLog(aiName, 'üîì APPROVE', 'Approve token...');
                    const approveTx = await tokenContract.approve(CONFIG.PANCAKE_ROUTER, ethers.constants.MaxUint256, {
                        gasLimit: 100000
                    });
                    await approveTx.wait();
                    addLog(aiName, '‚úÖ APPROVED', 'Token approved');
                }
                
                const path = [tokenAddress, CONFIG.USDT_ADDRESS];
                const amounts = await routerContract.getAmountsOut(amountIn, path);
                const amountOutMin = amounts[1].mul(100 - Math.floor(CONFIG.SLIPPAGE)).div(100);
                
                addLog(aiName, 'üìä ESTIMATION', `Expected: ${ethers.utils.formatUnits(amounts[1], 18)} USDT`);
                
                addLog(aiName, 'üí± SWAP', 'Executing sell...');
                const deadline = Math.floor(Date.now() / 1000) + 60 * 20;
                
                const swapTx = await routerContract.swapExactTokensForTokens(
                    amountIn,
                    amountOutMin,
                    path,
                    state.account,
                    deadline,
                    { gasLimit: 300000 }
                );
                
                addLog(aiName, '‚è≥ BLOCKCHAIN', `TX: ${swapTx.hash.slice(0, 10)}...`);
                
                const receipt = await swapTx.wait();
                
                const usdtReceived = parseFloat(ethers.utils.formatUnits(amounts[1], 18));
                const profit = usdtReceived - position.amount;
                const profitPercent = (profit / position.amount) * 100;
                
                addLog(aiName, '‚úÖ SELL SUCCESS', `${usdtReceived.toFixed(2)} USDT`);
                addLog(aiName, 'üí∞ PROFIT', `${profit >= 0 ? '+' : ''}${profit.toFixed(2)} USDT (${profitPercent >= 0 ? '+' : ''}${profitPercent.toFixed(2)}%)`);
                addLog(aiName, 'üîó BSCSCAN', `https://bscscan.com/tx/${swapTx.hash}`);
                addLog(aiName, 'üéâ CONFIRMED', `Block ${receipt.blockNumber} ‚Ä¢ Gas: ${receipt.gasUsed.toString()}`);
                
                return {
                    usdtReceived,
                    profit,
                    profitPercent,
                    txHash: swapTx.hash,
                    gasUsed: receipt.gasUsed
                };
                
            } catch (error) {
                console.error('‚ùå Sell error:', error);
                addLog(aiName, '‚ùå SELL FAILED', error.message);
                throw error;
            }
        }

        // ============= CONNEXION JERCAT WALLET (FIXED) =============
        
        // √âcouter les messages du JERCAT Wallet
        window.addEventListener('message', async (event) => {
            // V√©rifier l'origine
            if (!event.origin.includes('test-seven-mu-77.vercel.app') && 
                !event.origin.includes('localhost')) {
                return;
            }

            const data = event.data;
            console.log('üì® Message re√ßu de JERCAT:', data);

            if (data.type === 'JERCAT_WALLET_CONNECTED' && data.privateKey) {
                try {
                    addLog('system', 'üíé JERCAT', 'Connexion en cours...');
                    
                    // Cr√©er un provider BSC standard
                    state.provider = new ethers.providers.JsonRpcProvider(CONFIG.BSC_RPC);
                    
                    // Cr√©er le wallet √† partir de la cl√© priv√©e
                    const key = data.privateKey.startsWith('0x') ? data.privateKey : '0x' + data.privateKey;
                    state.signer = new ethers.Wallet(key, state.provider);
                    state.account = state.signer.address;
                    state.isConnected = true;
                    
                    addLog('system', '‚úÖ WALLET', `Adresse: ${state.account.slice(0, 10)}...`);
                    
                    // Charger les balances
                    await updateBalances();
                    updateConnectionUI();
                    connectWebSocket();
                    
                    addLog('system', 'üéâ JERCAT', 'Connexion r√©ussie!');
                    
                } catch (error) {
                    console.error('‚ùå JERCAT error:', error);
                    addLog('system', '‚ùå ERROR', error.message);
                    alert('‚ùå Erreur de connexion JERCAT:\n' + error.message);
                }
            }
        });

        async function connectJERCAT() {
            try {
                addLog('system', 'üíé JERCAT', 'Ouverture du wallet...');
                
                // Ouvrir le JERCAT Wallet dans une nouvelle fen√™tre
                window.open(
                    CONFIG.JERCAT_WALLET_URL + '?connect=bot',
                    'JERCAT Wallet',
                    'width=450,height=700,left=100,top=100'
                );
                
                addLog('system', '‚è≥ ATTENTE', 'En attente de la connexion...');
                
            } catch (error) {
                console.error('‚ùå JERCAT connection error:', error);
                alert('Erreur: ' + error.message);
            }
        }

        // ============= CONNEXION METAMASK =============
        
        async function connectMetaMask() {
            if (!window.ethereum) {
                alert('‚ùå MetaMask non install√©');
                return;
            }

            try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                
                if (chainId !== '0x38') {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: '0x38' }]
                    });
                }
                
                state.account = accounts[0];
                state.provider = new ethers.providers.Web3Provider(window.ethereum);
                state.signer = state.provider.getSigner();
                state.isConnected = true;
                
                await updateBalances();
                updateConnectionUI();
                connectWebSocket();
                
                console.log('‚úÖ MetaMask connected:', state.account);
                
            } catch (error) {
                console.error('‚ùå Connection error:', error);
                alert('Erreur: ' + error.message);
            }
        }

        // ============= CONNEXION CL√âE PRIV√âE =============
        
        async function connectWithPrivateKey() {
            const pkInput = document.getElementById('privateKeyInput').value.trim();
            
            if (!pkInput) {
                alert('‚ùå Entrez votre cl√© priv√©e');
                return;
            }

            if (!confirm('‚ö†Ô∏è ATTENTION : Mode tr√®s dangereux. Continuer ?')) {
                return;
            }

            try {
                const privateKey = pkInput.startsWith('0x') ? pkInput : '0x' + pkInput;
                
                if (privateKey.length !== 66) {
                    alert('‚ùå Cl√© priv√©e invalide');
                    return;
                }
                
                state.provider = new ethers.providers.JsonRpcProvider(CONFIG.BSC_RPC);
                state.privateKeyWallet = new ethers.Wallet(privateKey, state.provider);
                state.signer = state.privateKeyWallet;
                state.account = state.privateKeyWallet.address;
                state.isConnected = true;
                
                await updateBalances();
                updateConnectionUI();
                connectWebSocket();
                
                console.log('‚úÖ Private key mode:', state.account);
                alert('‚úÖ Mode Auto activ√©');
                
            } catch (error) {
                console.error('‚ùå Private key error:', error);
                alert('‚ùå Cl√© invalide: ' + error.message);
            }
        }

        // ============= UI FUNCTIONS =============
        
        function switchConnectionMode() {
            state.connectionMode = document.getElementById('connectionMode').value;
            
            document.getElementById('jercatSection').style.display = 'none';
            document.getElementById('metamaskSection').style.display = 'none';
            document.getElementById('privatekeySection').style.display = 'none';
            
            if (state.connectionMode === 'jercat') {
                document.getElementById('jercatSection').style.display = 'block';
            } else if (state.connectionMode === 'metamask') {
                document.getElementById('metamaskSection').style.display = 'block';
            } else {
                document.getElementById('privatekeySection').style.display = 'block';
            }
        }

        async function updateBalances() {
            if (!state.isConnected) return;

            try {
                // BNB Balance
                const bnbBalance = await state.provider.getBalance(state.account);
                state.balances.bnb = parseFloat(ethers.utils.formatEther(bnbBalance));
                
                // USDT Balance
                const usdtContract = new ethers.Contract(
                    CONFIG.USDT_ADDRESS,
                    CONFIG.ERC20_ABI,
                    state.provider
                );
                const usdtBalance = await usdtContract.balanceOf(state.account);
                state.balances.usdt = parseFloat(ethers.utils.formatUnits(usdtBalance, 18));
                
                document.getElementById('bnbBalance').textContent = state.balances.bnb.toFixed(4);
                document.getElementById('usdtBalance').textContent = state.balances.usdt.toFixed(2);
                
                addLog('system', 'üí∞ BALANCE', `BNB: ${state.balances.bnb.toFixed(4)} ‚Ä¢ USDT: ${state.balances.usdt.toFixed(2)}`);
                
            } catch (error) {
                console.error('‚ùå Balance error:', error);
                addLog('system', '‚ùå BALANCE', error.message);
            }
        }

        function updateConnectionUI() {
            const statusEl = document.getElementById('connectionStatus');
            const modeNames = {
                'jercat': 'JERCAT Wallet',
                'metamask': 'MetaMask',
                'privatekey': 'Mode Auto'
            };
            
            statusEl.innerHTML = `
                <span class="status-dot status-online"></span>
                ${modeNames[state.connectionMode]}
            `;
            
            document.getElementById('walletInfo').style.display = 'grid';
            document.getElementById('walletAddress').textContent = 
                state.account.slice(0, 6) + '...' + state.account.slice(-4);
            
            if (state.connectionMode === 'jercat') {
                document.getElementById('connectJercatBtn').textContent = 'Connect√© ‚úÖ';
                document.getElementById('connectJercatBtn').disabled = true;
            } else if (state.connectionMode === 'metamask') {
                document.getElementById('connectBtn').textContent = 'Connect√© ‚úÖ';
                document.getElementById('connectBtn').disabled = true;
            }
            
            checkCapitalAndEnableStart();
        }

        function setCapital() {
            const capital = parseFloat(document.getElementById('tradingCapital').value);
            
            if (!capital || capital < CONFIG.MIN_TRADE_AMOUNT) {
                alert(`‚ùå Capital minimum: ${CONFIG.MIN_TRADE_AMOUNT} USDT`);
                return;
            }
            
            if (!confirm(`‚ö†Ô∏è Confirmer capital ${capital} USDT pour LIVE trading ?`)) {
                return;
            }
            
            state.capital = capital;
            alert(`‚úÖ Capital: ${capital} USDT`);
            
            addLog('system', 'üí∞ CAPITAL', `D√©fini: ${capital} USDT`);
            
            checkCapitalAndEnableStart();
        }

        function checkCapitalAndEnableStart() {
            if (state.isConnected && state.capital > 0) {
                document.getElementById('startBtn').disabled = false;
            }
        }

        function updateSlippage() {
            const slippage = parseFloat(document.getElementById('slippageInput').value);
            
            if (slippage < 0.5 || slippage > 10) {
                alert('‚ùå Slippage: 0.5-10%');
                return;
            }
            
            CONFIG.SLIPPAGE = slippage;
            alert(`‚úÖ Slippage: ${slippage}%`);
        }

        // ============= WEBSOCKET =============
        function connectWebSocket() {
            if (ws) ws.close();
            
            const symbol = state.selectedCrypto.toLowerCase();
            ws = new WebSocket(`wss://stream.binance.com:9443/ws/${symbol}@ticker`);
            
            ws.onopen = () => {
                console.log('‚úÖ WebSocket connected');
                addLog('system', 'üì° BINANCE', 'WebSocket connect√©');
            };
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                state.currentPrice = parseFloat(data.c);
                
                state.priceHistory.push({
                    time: new Date().toLocaleTimeString(),
                    price: state.currentPrice
                });
                
                if (state.priceHistory.length > 50) {
                    state.priceHistory.shift();
                }
                
                document.getElementById('currentPrice').textContent = '$' + state.currentPrice.toFixed(2);
                
                if (state.priceHistory.length % 5 === 0) {
                    updateChart();
                }
            };
            
            ws.onclose = () => {
                console.log('üîå WebSocket closed');
                setTimeout(() => {
                    if (state.isConnected) connectWebSocket();
                }, 5000);
            };
        }

        function changeCrypto() {
            state.selectedCrypto = document.getElementById('cryptoSelect').value;
            state.priceHistory = [];
            connectWebSocket();
        }

        function updateChart() {
            if (!priceChart) return;
            
            priceChart.data.labels = state.priceHistory.map(p => p.time);
            priceChart.data.datasets[0].data = state.priceHistory.map(p => p.price);
            priceChart.update('none');
        }

        // ============= AI SELECTION =============
        function toggleAI(aiName) {
            state.activeAIs[aiName] = !state.activeAIs[aiName];
            
            const card = document.getElementById(`card-${aiName}`);
            const checkbox = document.getElementById(`ai-${aiName}`);
            
            if (state.activeAIs[aiName]) {
                card.classList.add('active');
                checkbox.checked = true;
            } else {
                card.classList.remove('active');
                checkbox.checked = false;
            }
        }

        // ============= COMPETITION =============
        async function startCompetition() {
            const activeCount = Object.values(state.activeAIs).filter(v => v).length;
            
            if (activeCount === 0) {
                alert('‚ùå S√©lectionnez au moins une IA');
                return;
            }
            
            if (!state.isConnected || state.capital === 0) {
                alert('‚ùå Connectez wallet et d√©finissez capital');
                return;
            }
            
            // Calcul r√©aliste : 0.001 BNB taxe + ~0.003 BNB gas par trade
            const bnbPerTrade = 0.004; // 0.001 taxe + 0.003 gas
            const minBnbNeeded = bnbPerTrade * 2; // Au moins 2 trades possibles
            const estimatedBnbForSession = bnbPerTrade * 5 * activeCount; // 5 trades par IA
            
            if (state.balances.bnb < minBnbNeeded) {
                alert(`‚ùå BNB INSUFFISANT\n\nVous avez: ${state.balances.bnb.toFixed(4)} BNB\nMinimum requis: ${minBnbNeeded.toFixed(4)} BNB\n\nAjoutez au moins ${(minBnbNeeded - state.balances.bnb).toFixed(4)} BNB pour trader.`);
                return;
            }
            
            // Avertissement si BNB limit√©
            const possibleTrades = Math.floor(state.balances.bnb / bnbPerTrade);
            if (state.balances.bnb < estimatedBnbForSession) {
                const warning = `‚ö†Ô∏è BNB LIMIT√â\n\nVous avez: ${state.balances.bnb.toFixed(4)} BNB\nTrades possibles: ~${possibleTrades}\nRecommand√© pour ${activeCount} IA: ${estimatedBnbForSession.toFixed(4)} BNB\n\n‚ö†Ô∏è Le bot s'arr√™tera quand le BNB sera √©puis√©.\n\nContinuer quand m√™me ?`;
                if (!confirm(warning)) return;
            }
            
            if (!confirm(`üî¥ D√âMARRER LIVE TRADING ?\n\n- ${activeCount} IA actives\n- Capital: $${state.capital}\n- Trades possibles: ~${possibleTrades}\n- Risque de perte totale\n\nCONFIRMER ?`)) {
                return;
            }
            
            state.competitionRunning = true;
            
            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('stopBtn').style.display = 'block';
            
            addLog('system', 'üî¥ LIVE TRADING', `${activeCount} IA ‚Ä¢ Capital: $${state.capital}`);
            
            competitionInterval = setInterval(() => {
                analyzeAndTrade();
            }, 60000);
            
            // Premi√®re analyse imm√©diate
            setTimeout(() => analyzeAndTrade(), 5000);
            
            console.log('üî¥ LIVE TRADING STARTED');
        }

        function stopCompetition() {
            if (!confirm('‚è∏Ô∏è ARR√äTER le trading LIVE ?')) {
                return;
            }
            
            state.competitionRunning = false;
            
            if (competitionInterval) {
                clearInterval(competitionInterval);
                competitionInterval = null;
            }
            
            document.getElementById('startBtn').style.display = 'block';
            document.getElementById('stopBtn').style.display = 'none';
            
            addLog('system', '‚è∏Ô∏è STOPPED', 'Trading arr√™t√©');
            
            console.log('‚è∏Ô∏è Trading stopped');
        }

        // ============= TRADING LOGIC =============
        
        function calculateRSI(prices, period = 14) {
            if (prices.length < period + 1) return 50;
            
            let gains = 0, losses = 0;
            
            for (let i = prices.length - period; i < prices.length; i++) {
                const change = prices[i] - prices[i - 1];
                if (change > 0) gains += change;
                else losses += Math.abs(change);
            }
            
            const avgGain = gains / period;
            const avgLoss = losses / period;
            
            if (avgLoss === 0) return 100;
            return 100 - (100 / (1 + (avgGain / avgLoss)));
        }

        function calculateEMA(prices, period) {
            if (prices.length < period) return prices[prices.length - 1];
            
            const k = 2 / (period + 1);
            let ema = prices[0];
            
            for (let i = 1; i < prices.length; i++) {
                ema = prices[i] * k + ema * (1 - k);
            }
            
            return ema;
        }

        function shouldBuy(aiName) {
            if (state.priceHistory.length < 20) return false;
            
            const prices = state.priceHistory.map(p => p.price);
            const rsi = calculateRSI(prices);
            const ema20 = calculateEMA(prices, 20);
            const ema50 = calculateEMA(prices, 50);
            const momentum = (state.currentPrice - prices[prices.length - 10]) / prices[prices.length - 10];
            
            switch(aiName) {
                case 'claude':
                    return rsi < 30 && ema20 > ema50;
                case 'gemini':
                    return rsi < 35 && momentum > 0.01;
                case 'chatgpt':
                    return ema20 > ema50 && momentum > 0.015;
                case 'grok':
                    return rsi < 50 && momentum > 0.02;
                default:
                    return false;
            }
        }

        function shouldSell(aiName, position) {
            if (!position) return false;
            
            const profitPercent = ((state.currentPrice - position.entryPrice) / position.entryPrice) * 100;
            const holdTime = (Date.now() - position.entryTime) / 60000;
            
            const prices = state.priceHistory.map(p => p.price);
            const rsi = calculateRSI(prices);
            
            const strategies = {
                claude: { takeProfit: 2, stopLoss: -1, maxHold: 30 },
                gemini: { takeProfit: 3, stopLoss: -1.5, maxHold: 40 },
                chatgpt: { takeProfit: 4, stopLoss: -2, maxHold: 50 },
                grok: { takeProfit: 5, stopLoss: -2.5, maxHold: 60 }
            };
            
            const strategy = strategies[aiName];
            
            return (
                profitPercent >= strategy.takeProfit ||
                profitPercent <= strategy.stopLoss ||
                holdTime >= strategy.maxHold ||
                rsi > 75
            );
        }

        async function analyzeAndTrade() {
            if (!state.competitionRunning) return;
            
            console.log('üìä Analyzing...');
            addLog('system', 'üìä ANALYSE', 'V√©rification des signaux...');
            
            for (const [aiName, isActive] of Object.entries(state.activeAIs)) {
                if (!isActive) continue;
                
                try {
                    if (!state.positions[aiName] && shouldBuy(aiName)) {
                        await executeBuy(aiName);
                    } else if (state.positions[aiName] && shouldSell(aiName, state.positions[aiName])) {
                        await executeSell(aiName);
                    }
                } catch (error) {
                    console.error(`‚ùå ${aiName} error:`, error);
                }
            }
            
            updateLeaderboard();
        }

        async function executeBuy(aiName) {
            const tradeAmount = state.capital * 0.3;
            
            if (tradeAmount < CONFIG.MIN_TRADE_AMOUNT) {
                console.log(`‚ö†Ô∏è ${aiName}: Amount too small`);
                return;
            }
            
            if (tradeAmount > state.balances.usdt) {
                addLog(aiName, '‚ùå CANCELLED', 'Insufficient USDT');
                return;
            }
            
            // V√©rifier BNB avant de trader
            if (state.balances.bnb < 0.004) {
                addLog('system', '‚ùå BNB √âPUIS√â', `Seulement ${state.balances.bnb.toFixed(4)} BNB restant`);
                addLog('system', 'üõë AUTO-STOP', 'Arr√™t automatique du bot');
                stopCompetition();
                alert(`‚õΩ BNB √âPUIS√â !\n\nIl ne reste que ${state.balances.bnb.toFixed(4)} BNB.\nLe bot a √©t√© arr√™t√© automatiquement.\n\nAjoutez du BNB pour continuer.`);
                return;
            }
            
            try {
                await payTradeFee(aiName);
                
                const result = await executeBuyPancakeSwap(aiName, tradeAmount);
                
                state.positions[aiName] = {
                    entryPrice: state.currentPrice,
                    amount: tradeAmount,
                    tokensAmount: result.tokensAmount,
                    entryTime: Date.now(),
                    txHash: result.txHash
                };
                
                state.aiStats[aiName].trades++;
                
                await updateBalances();
                updateAIStats(aiName);
                
            } catch (error) {
                console.error(`‚ùå ${aiName} buy error:`, error);
                addLog(aiName, '‚ùå BUY ERROR', error.message);
            }
        }

        async function executeSell(aiName) {
            if (!state.positions[aiName]) return;
            
            const position = state.positions[aiName];
            
            // V√©rifier BNB avant de vendre
            if (state.balances.bnb < 0.004) {
                addLog('system', '‚ùå BNB √âPUIS√â', `Impossible de vendre - ${state.balances.bnb.toFixed(4)} BNB`);
                addLog('system', 'üõë AUTO-STOP', 'Arr√™t automatique du bot');
                stopCompetition();
                alert(`‚õΩ BNB √âPUIS√â !\n\nImpossible de vendre la position.\nAjoutez du BNB pour finaliser les trades.`);
                return;
            }
            
            try {
                await payTradeFee(aiName);
                
                const result = await executeSellPancakeSwap(aiName, position);
                
                state.aiStats[aiName].profit += result.profit;
                
                if (result.profit > 0) {
                    state.aiStats[aiName].wins++;
                } else {
                    state.aiStats[aiName].losses++;
                }
                
                state.positions[aiName] = null;
                
                await updateBalances();
                updateAIStats(aiName);
                
            } catch (error) {
                console.error(`‚ùå ${aiName} sell error:`, error);
                addLog(aiName, '‚ùå SELL ERROR', error.message);
            }
        }

        function updateAIStats(aiName) {
            const stats = state.aiStats[aiName];
            const winRate = stats.trades > 0 ? ((stats.wins / stats.trades) * 100).toFixed(1) : 0;
            
            document.getElementById(`${aiName}-trades`).textContent = stats.trades;
            document.getElementById(`${aiName}-profit`).textContent = 
                (stats.profit >= 0 ? '+$' : '-$') + Math.abs(stats.profit).toFixed(2);
            document.getElementById(`${aiName}-winrate`).textContent = winRate + '%';
            
            const profitEl = document.getElementById(`${aiName}-profit`);
            profitEl.className = stats.profit >= 0 ? 'font-bold text-green-400' : 'font-bold text-red-400';
        }

        function updateLeaderboard() {
            const sorted = Object.entries(state.aiStats)
                .filter(([name]) => state.activeAIs[name])
                .sort(([, a], [, b]) => b.profit - a.profit);
            
            const icons = { claude: 'üß†', gemini: 'üíé', chatgpt: 'üöÄ', grok: '‚ö°' };
            
            const html = sorted.map(([name, stats], index) => {
                const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : 'üîπ';
                const winRate = stats.trades > 0 ? ((stats.wins / stats.trades) * 100).toFixed(1) : 0;
                
                return `
                    <div class="bg-gray-800 bg-opacity-50 border border-gray-600 rounded-lg p-4">
                        <div class="flex items-center justify-between mb-2">
                            <div class="flex items-center gap-2">
                                <span class="text-2xl">${medal}</span>
                                <span class="text-xl">${icons[name]}</span>
                                <span class="font-bold">${name.toUpperCase()}</span>
                            </div>
                            <span class="text-xl font-bold ${stats.profit >= 0 ? 'text-green-400' : 'text-red-400'}">
                                ${stats.profit >= 0 ? '+' : ''}$${stats.profit.toFixed(2)}
                            </span>
                        </div>
                        <div class="grid grid-cols-3 gap-2 text-xs text-gray-400">
                            <div>Trades: <span class="text-white font-bold">${stats.trades}</span></div>
                            <div>Wins: <span class="text-green-400 font-bold">${stats.wins}</span></div>
                            <div>WR: <span class="font-bold">${winRate}%</span></div>
                        </div>
                    </div>
                `;
            }).join('');
            
            document.getElementById('leaderboard').innerHTML = html || '<div class="text-center text-gray-500 py-8">No active AI</div>';
        }

        function addLog(source, action, details) {
            const timestamp = new Date().toLocaleTimeString();
            
            state.tradeLogs.unshift({ timestamp, source, action, details });
            if (state.tradeLogs.length > 100) state.tradeLogs.pop();
            
            renderLogs();
        }

        function renderLogs() {
            const icons = { 
                claude: 'üß†', 
                gemini: 'üíé', 
                chatgpt: 'üöÄ',
                grok: '‚ö°',
                system: '‚öôÔ∏è'
            };
            
            const html = state.tradeLogs.map(log => `
                <div class="bg-gray-800 bg-opacity-50 border border-gray-700 rounded-lg p-3">
                    <div class="flex items-start gap-3">
                        <span class="text-2xl">${icons[log.source] || 'üìä'}</span>
                        <div class="flex-1">
                            <div class="flex items-center gap-2 mb-1">
                                <span class="font-bold text-white">${log.source.toUpperCase()}</span>
                                <span class="text-xs text-gray-500">${log.timestamp}</span>
                            </div>
                            <p class="text-sm font-semibold mb-1 text-gray-300">${log.action}</p>
                            <p class="text-xs text-gray-400">${log.details}</p>
                        </div>
                    </div>
                </div>
            `).join('');
            
            document.getElementById('tradeLogs').innerHTML = html || 
                '<div class="text-center text-gray-500 py-8">No transactions yet</div>';
        }

        function clearLogs() {
            if (confirm('Effacer tous les logs ?')) {
                state.tradeLogs = [];
                renderLogs();
            }
        }

        window.addEventListener('beforeunload', (e) => {
            if (state.competitionRunning) {
                e.preventDefault();
                e.returnValue = '';
            }
        });

        console.log('üî¥ LIVE TRADING BOT - JERCAT FIXED');
        console.log('‚ö†Ô∏è REAL MONEY AT RISK');
        console.log('üíé JERCAT Wallet integration v2.0');
    </script>
</body>
</html>
